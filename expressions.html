

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Expressions &mdash; The Lean Reference Manual master documentation</title>
  

  
  
  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  

  

  
        <link rel="index" title="Index"
              href="genindex.html"/>
        <link rel="search" title="Search" href="search.html"/>
    <link rel="top" title="The Lean Reference Manual master documentation" href="index.html"/>
        <link rel="next" title="Declarations" href="declarations.html"/>
        <link rel="prev" title="Lexical Structure" href="lexical_structure.html"/> 

  
  <script src="_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="index.html" class="icon icon-home"> The Lean Reference Manual
          

          
          </a>

          
            
            
              <div class="version">
                master
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="lexical_structure.html">Lexical Structure</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Expressions</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#universes">Universes</a></li>
<li class="toctree-l2"><a class="reference internal" href="#expression-syntax">Expression Syntax</a></li>
<li class="toctree-l2"><a class="reference internal" href="#implicit-arguments">Implicit Arguments</a></li>
<li class="toctree-l2"><a class="reference internal" href="#basic-data-types-and-assertions">Basic Data Types and Assertions</a></li>
<li class="toctree-l2"><a class="reference internal" href="#constructors-projections-and-matching">Constructors, Projections, and Matching</a></li>
<li class="toctree-l2"><a class="reference internal" href="#structured-proofs">Structured Proofs</a></li>
<li class="toctree-l2"><a class="reference internal" href="#computation">Computation</a></li>
<li class="toctree-l2"><a class="reference internal" href="#axioms">Axioms</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="declarations.html">Declarations</a></li>
<li class="toctree-l1"><a class="reference internal" href="infrastructure.html">Infrastructure</a></li>
<li class="toctree-l1"><a class="reference internal" href="tactics.html">Tactics</a></li>
<li class="toctree-l1"><a class="reference internal" href="programming.html">Programming</a></li>
<li class="toctree-l1"><a class="reference internal" href="libraries.html">Libraries</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">The Lean Reference Manual</a>
        
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
      <li>Expressions</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/expressions.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="expressions">
<span id="id1"></span><h1>Expressions<a class="headerlink" href="#expressions" title="Permalink to this headline">¶</a></h1>
<div class="section" id="universes">
<h2>Universes<a class="headerlink" href="#universes" title="Permalink to this headline">¶</a></h2>
<p>Every type in Lean is, by definition, an expression of type <code class="docutils literal"><span class="pre">Sort</span> <span class="pre">u</span></code> for some universe level <code class="docutils literal"><span class="pre">u</span></code>. A universe level is one of the following:</p>
<ul class="simple">
<li>a natural number, <code class="docutils literal"><span class="pre">n</span></code></li>
<li>a universe variable, <code class="docutils literal"><span class="pre">u</span></code> (declared with the command <code class="docutils literal"><span class="pre">universe</span></code> or <code class="docutils literal"><span class="pre">universes</span></code>)</li>
<li>an expression <code class="docutils literal"><span class="pre">u</span> <span class="pre">+</span> <span class="pre">n</span></code>, where <code class="docutils literal"><span class="pre">u</span></code> is a universe level and <code class="docutils literal"><span class="pre">n</span></code> is a natural number</li>
<li>an expression <code class="docutils literal"><span class="pre">max</span> <span class="pre">u</span> <span class="pre">v</span></code>, where <code class="docutils literal"><span class="pre">u</span></code> and <code class="docutils literal"><span class="pre">v</span></code> are universes</li>
<li>an expression <code class="docutils literal"><span class="pre">imax</span> <span class="pre">u</span> <span class="pre">v</span></code>, where <code class="docutils literal"><span class="pre">u</span></code> and <code class="docutils literal"><span class="pre">v</span></code> are universe levels</li>
</ul>
<p>The last one denotes the universe level <code class="docutils literal"><span class="pre">0</span></code> if <code class="docutils literal"><span class="pre">v</span></code> is <code class="docutils literal"><span class="pre">0</span></code>, and <code class="docutils literal"><span class="pre">max</span> <span class="pre">u</span> <span class="pre">v</span></code> otherwise.</p>
<p><strong>Examples</strong></p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://gebner.github.io/lean-web-editor/#code=universes%20u%20v%0A%0A#check%20Sort%20u%0A#check%20Sort%205%0A#check%20Sort%20(u%20+%201)%0A#check%20Sort%20(u%20+%203)%0A#check%20Sort%20(max%20u%20v)%0A#check%20Sort%20(max%20(u%20+%203)%20v)%0A#check%20Sort%20(imax%20(u%20+%203)%20v)%0A#check%20Prop%0A#check%20Type" target="_blank">
try it!</a></div><div class="highlight-lean"><div class="highlight"><pre><span class="kn">universes</span> <span class="n">u</span> <span class="n">v</span>

<span class="bp">#</span><span class="n">check</span> <span class="kt">Sort</span> <span class="n">u</span>
<span class="bp">#</span><span class="n">check</span> <span class="kt">Sort</span> <span class="mi">5</span>
<span class="bp">#</span><span class="n">check</span> <span class="kt">Sort</span> <span class="o">(</span><span class="n">u</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span>
<span class="bp">#</span><span class="n">check</span> <span class="kt">Sort</span> <span class="o">(</span><span class="n">u</span> <span class="bp">+</span> <span class="mi">3</span><span class="o">)</span>
<span class="bp">#</span><span class="n">check</span> <span class="kt">Sort</span> <span class="o">(</span><span class="n">max</span> <span class="n">u</span> <span class="n">v</span><span class="o">)</span>
<span class="bp">#</span><span class="n">check</span> <span class="kt">Sort</span> <span class="o">(</span><span class="n">max</span> <span class="o">(</span><span class="n">u</span> <span class="bp">+</span> <span class="mi">3</span><span class="o">)</span> <span class="n">v</span><span class="o">)</span>
<span class="bp">#</span><span class="n">check</span> <span class="kt">Sort</span> <span class="o">(</span><span class="n">imax</span> <span class="o">(</span><span class="n">u</span> <span class="bp">+</span> <span class="mi">3</span><span class="o">)</span> <span class="n">v</span><span class="o">)</span>
<span class="bp">#</span><span class="n">check</span> <span class="kt">Prop</span>
<span class="bp">#</span><span class="n">check</span> <span class="kt">Type</span>
</pre></div>
</div>
</div></div>
<div class="section" id="expression-syntax">
<h2>Expression Syntax<a class="headerlink" href="#expression-syntax" title="Permalink to this headline">¶</a></h2>
<p>The set of expressions in Lean is defined inductively as follows:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">Sort</span> <span class="pre">u</span></code> : the universe of types at universe level <code class="docutils literal"><span class="pre">u</span></code></li>
<li><code class="docutils literal"><span class="pre">c</span></code> : where <code class="docutils literal"><span class="pre">c</span></code> is an identifier denoting an axiomatically declared constant or a defined object</li>
<li><code class="docutils literal"><span class="pre">x</span></code> : where <code class="docutils literal"><span class="pre">x</span></code> is a variable the local context in which the expression is interpreted</li>
<li><code class="docutils literal"><span class="pre">Π</span> <span class="pre">x</span> <span class="pre">:</span> <span class="pre">α,</span> <span class="pre">β</span></code> : the type of functions taking an element <code class="docutils literal"><span class="pre">x</span></code> of <code class="docutils literal"><span class="pre">α</span></code> to an element of <code class="docutils literal"><span class="pre">β</span></code>, where <code class="docutils literal"><span class="pre">β</span></code> is an expression whose type is a <code class="docutils literal"><span class="pre">Sort</span></code></li>
<li><code class="docutils literal"><span class="pre">s</span> <span class="pre">t</span></code> : the result of applying <code class="docutils literal"><span class="pre">s</span></code> to <code class="docutils literal"><span class="pre">t</span></code>, where <code class="docutils literal"><span class="pre">s</span></code> and <code class="docutils literal"><span class="pre">t</span></code> are expressions</li>
<li><code class="docutils literal"><span class="pre">λ</span> <span class="pre">x</span> <span class="pre">:</span> <span class="pre">α,</span> <span class="pre">t</span></code> : the function mapping any value <code class="docutils literal"><span class="pre">x</span></code> of type <code class="docutils literal"><span class="pre">α</span></code> to <code class="docutils literal"><span class="pre">t</span></code>, where <code class="docutils literal"><span class="pre">t</span></code> is an expression</li>
<li><code class="docutils literal"><span class="pre">let</span> <span class="pre">x</span> <span class="pre">:=</span> <span class="pre">t</span> <span class="pre">in</span> <span class="pre">s</span></code> : a local definition, denote the value of <code class="docutils literal"><span class="pre">s</span></code> when <code class="docutils literal"><span class="pre">x</span></code> denotes <code class="docutils literal"><span class="pre">t</span></code></li>
</ul>
<p>Every well formed term in Lean has a <em>type</em>, which itself is an expression of type <code class="docutils literal"><span class="pre">Sort</span> <span class="pre">u</span></code> for some <code class="docutils literal"><span class="pre">u</span></code>. The fact that a term <code class="docutils literal"><span class="pre">t</span></code> has type <code class="docutils literal"><span class="pre">α</span></code> is written <code class="docutils literal"><span class="pre">t</span> <span class="pre">:</span> <span class="pre">α</span></code>.</p>
<p>For an expression to be well formed, its components have to satisfy certain typing constraints. These, in turn, determine the type of the resulting term, as follows:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">Sort</span> <span class="pre">u</span> <span class="pre">:</span> <span class="pre">Sort</span> <span class="pre">(u</span> <span class="pre">+</span> <span class="pre">1)</span></code></li>
<li><code class="docutils literal"><span class="pre">c</span> <span class="pre">:</span> <span class="pre">α</span></code>, where <code class="docutils literal"><span class="pre">α</span></code> is the type that <code class="docutils literal"><span class="pre">c</span></code> has been declared or defined to have</li>
<li><code class="docutils literal"><span class="pre">x</span> <span class="pre">:</span> <span class="pre">α</span></code>, where <code class="docutils literal"><span class="pre">α</span></code> is the type that <code class="docutils literal"><span class="pre">x</span></code> has been assigned in the local context where it is interpreted</li>
<li><code class="docutils literal"><span class="pre">(Π</span> <span class="pre">x</span> <span class="pre">:</span> <span class="pre">α,</span> <span class="pre">β)</span> <span class="pre">:</span> <span class="pre">Sort</span> <span class="pre">(imax</span> <span class="pre">u</span> <span class="pre">v)</span></code> where <code class="docutils literal"><span class="pre">α</span> <span class="pre">:</span> <span class="pre">Sort</span> <span class="pre">u</span></code>, and <code class="docutils literal"><span class="pre">β</span> <span class="pre">:</span> <span class="pre">Sort</span> <span class="pre">v</span></code> assuming <code class="docutils literal"><span class="pre">x</span> <span class="pre">:</span> <span class="pre">α</span></code></li>
<li><code class="docutils literal"><span class="pre">s</span> <span class="pre">t</span> <span class="pre">:</span> <span class="pre">β</span> <span class="pre">[t/x]</span></code> where <code class="docutils literal"><span class="pre">s</span></code> has type <code class="docutils literal"><span class="pre">Π</span> <span class="pre">x</span> <span class="pre">:</span> <span class="pre">α,</span> <span class="pre">β</span></code> and <code class="docutils literal"><span class="pre">t</span></code> has type <code class="docutils literal"><span class="pre">α</span></code></li>
<li><code class="docutils literal"><span class="pre">(λ</span> <span class="pre">x</span> <span class="pre">:</span> <span class="pre">α,</span> <span class="pre">t)</span> <span class="pre">:</span> <span class="pre">Π</span> <span class="pre">x</span> <span class="pre">:</span> <span class="pre">α,</span> <span class="pre">β</span></code> if <code class="docutils literal"><span class="pre">t</span></code> has type <code class="docutils literal"><span class="pre">β</span></code> whenever <code class="docutils literal"><span class="pre">x</span></code> has type <code class="docutils literal"><span class="pre">α</span></code></li>
<li><code class="docutils literal"><span class="pre">(let</span> <span class="pre">x</span> <span class="pre">:=</span> <span class="pre">t</span> <span class="pre">in</span> <span class="pre">s)</span> <span class="pre">:</span> <span class="pre">β</span> <span class="pre">[t/x]</span></code> where <code class="docutils literal"><span class="pre">s</span></code> has type <code class="docutils literal"><span class="pre">Π</span> <span class="pre">x</span> <span class="pre">:</span> <span class="pre">α,</span> <span class="pre">β</span></code>, and <code class="docutils literal"><span class="pre">t</span></code> has type <code class="docutils literal"><span class="pre">β</span></code> assuming <code class="docutils literal"><span class="pre">x</span> <span class="pre">:</span> <span class="pre">α</span></code></li>
</ul>
<p><code class="docutils literal"><span class="pre">Prop</span></code> abbreviates <code class="docutils literal"><span class="pre">Sort</span> <span class="pre">0</span></code>, <code class="docutils literal"><span class="pre">Type</span></code> abbreviates <code class="docutils literal"><span class="pre">Sort</span> <span class="pre">1</span></code>, and <code class="docutils literal"><span class="pre">Type</span> <span class="pre">u</span></code> abbreviates <code class="docutils literal"><span class="pre">Sort</span> <span class="pre">(u</span> <span class="pre">+</span> <span class="pre">1)</span></code> when <code class="docutils literal"><span class="pre">u</span></code> is a universe variable. We say “<code class="docutils literal"><span class="pre">α</span></code> is a type” to express <code class="docutils literal"><span class="pre">α</span> <span class="pre">:</span> <span class="pre">Type</span> <span class="pre">u</span></code> for some <code class="docutils literal"><span class="pre">u</span></code>, and we say “<code class="docutils literal"><span class="pre">p</span></code> is a proposition” to express <code class="docutils literal"><span class="pre">p</span> <span class="pre">:</span> <span class="pre">Prop</span></code>. Using the <em>propositions as types</em> correspondence, given <code class="docutils literal"><span class="pre">p</span> <span class="pre">:</span> <span class="pre">Prop</span></code>, we refer to an expression <code class="docutils literal"><span class="pre">t</span> <span class="pre">:</span> <span class="pre">p</span></code> as a <em>proof</em> of <code class="docutils literal"><span class="pre">p</span></code>. In contrast, given <code class="docutils literal"><span class="pre">α</span> <span class="pre">:</span> <span class="pre">Type</span> <span class="pre">u</span></code> for some <code class="docutils literal"><span class="pre">u</span></code> and <code class="docutils literal"><span class="pre">t</span> <span class="pre">:</span> <span class="pre">α</span></code>, we sometimes refer to <code class="docutils literal"><span class="pre">t</span></code> as <em>data</em>.</p>
<p>When the expression <code class="docutils literal"><span class="pre">β</span></code> in <code class="docutils literal"><span class="pre">Π</span> <span class="pre">x</span> <span class="pre">:</span> <span class="pre">α,</span> <span class="pre">β</span></code> does not depend on <code class="docutils literal"><span class="pre">x</span></code>, it can be written <code class="docutils literal"><span class="pre">α</span> <span class="pre">→</span> <span class="pre">β</span></code>. As usual, the variable <code class="docutils literal"><span class="pre">x</span></code> is bound in <code class="docutils literal"><span class="pre">Π</span> <span class="pre">x</span> <span class="pre">:</span> <span class="pre">α,</span> <span class="pre">β</span></code>, <code class="docutils literal"><span class="pre">λ</span> <span class="pre">x</span> <span class="pre">:</span> <span class="pre">α,</span> <span class="pre">t</span></code>, and <code class="docutils literal"><span class="pre">let</span> <span class="pre">x</span> <span class="pre">:=</span> <span class="pre">t</span> <span class="pre">in</span> <span class="pre">s</span></code>. The expression <code class="docutils literal"><span class="pre">∀</span> <span class="pre">x</span> <span class="pre">:</span> <span class="pre">α,</span> <span class="pre">β</span></code> is alternative syntax for <code class="docutils literal"><span class="pre">Π</span> <span class="pre">x</span> <span class="pre">:</span> <span class="pre">α,</span> <span class="pre">β</span></code>, and is intended to be used when <code class="docutils literal"><span class="pre">β</span></code> is a proposition. An underscore can be used to generate an internal variable in a binder, as in <code class="docutils literal"><span class="pre">λ</span> <span class="pre">_</span> <span class="pre">:</span> <span class="pre">α,</span> <span class="pre">t</span></code>.</p>
<p>In addition to the elements above, expressions can also contain <em>metavariables</em>, that is, temporary placeholders, that are used in the process of constructing terms. They can also contain <em>macros</em>, which are used to annotate or abbreviate terms. Terms that are added to the environment contain neither metavariable nor variables, which is to say, they are fully elaborated and make sense in the empty context.</p>
<p>Constants can be declared in various ways, such as by the <code class="docutils literal"><span class="pre">constant(s)</span></code> and <code class="docutils literal"><span class="pre">axiom(s)</span></code> keywords, or as the result of an <code class="docutils literal"><span class="pre">inductive</span></code> or <code class="docutils literal"><span class="pre">structure</span></code> declarations. Similarly, objects can be defined in various ways, such as using <code class="docutils literal"><span class="pre">def</span></code>, <code class="docutils literal"><span class="pre">theorem</span></code>, or the equation compiler. See <a class="reference internal" href="declarations.html"><span class="doc">Declarations</span></a> for more information.</p>
<p>Writing an expression <code class="docutils literal"><span class="pre">(t</span> <span class="pre">:</span> <span class="pre">α)</span></code> forces Lean to elaborate <code class="docutils literal"><span class="pre">t</span></code> so that it has type <code class="docutils literal"><span class="pre">α</span></code> or report an error if it fails.</p>
<p>Lean supports anonymous constructor notation, anonymous projections, and various forms of match syntax, including destructuring <code class="docutils literal"><span class="pre">λ</span></code> and <code class="docutils literal"><span class="pre">let</span></code>. These, as well as notation for common data types (like pairs, lists, and so on) are discussed in <a class="reference internal" href="declarations.html"><span class="doc">Declarations</span></a> in connection with inductive types.</p>
<p><strong>Examples</strong></p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://gebner.github.io/lean-web-editor/#code=universes%20u%20v%20w%0A%0Avariables%20(p%20q%20:%20Prop)%0Avariable%20%20(%CE%B1%20:%20Type%20u)%0Avariable%20%20(%CE%B2%20:%20Type%20v)%0Avariable%20%20(%CE%B3%20:%20%CE%B1%20%E2%86%92%20Type%20w)%0Avariable%20%20(%CE%B7%20:%20%CE%B1%20%E2%86%92%20%CE%B2%20%E2%86%92%20Type%20w)%0A%0Aconstants%20%CE%B4%20%CE%B5%20:%20Type%20u%0Aconstants%20cnst%20:%20%CE%B4%0Aconstant%20%20f%20:%20%CE%B4%20%E2%86%92%20%CE%B5%0A%0Avariables%20(a%20:%20%CE%B1)%20(b%20:%20%CE%B2)%20(c%20:%20%CE%B3%20a)%20(d%20:%20%CE%B4)%0A%0Avariable%20%20g%20%20:%20%CE%B1%20%E2%86%92%20%CE%B2%0Avariable%20%20h%20%20:%20%CE%A0%20x%20:%20%CE%B1,%20%CE%B3%20x%0Avariable%20%20h'%20:%20%CE%A0%20x,%20%CE%B3%20x%20%E2%86%92%20%CE%B4%0A%0A#check%20Sort%20(u%20+%203)%0A#check%20Prop%0A#check%20%CE%A0%20x%20:%20%CE%B1,%20%CE%B3%20x%0A#check%20f%20cnst%0A#check%20%CE%BB%20x,%20h%20x%0A#check%20%CE%BB%20x,%20h'%20x%20(h%20x)%0A#check%20(%CE%BB%20x,%20h%20x)%20a%0A#check%20%CE%BB%20_%20:%20%E2%84%95,%205%0A#check%20let%20x%20:=%20a%20in%20h%20x%0A%0A#check%20%CE%A0%20x%20y,%20%CE%B7%20x%20y%0A#check%20%CE%A0%20(x%20:%20%CE%B1)%20(y%20:%20%CE%B2),%20%CE%B7%20x%20y%0A#check%20%CE%BB%20x%20y,%20%CE%B7%20x%20y%0A#check%20%CE%BB%20(x%20:%20%CE%B1)%20(y%20:%20%CE%B2),%20%CE%B7%20x%20y%0A#check%20let%20x%20:=%20a,%20y%20:=%20b%20in%20%CE%B7%20x%20y%0A%0A#check%20(5%20:%20%E2%84%95)%0A#check%20(5%20:%20(%CE%BB%20x,%20x)%20%E2%84%95)%0A#check%20(5%20:%20%E2%84%A4)" target="_blank">
try it!</a></div><div class="highlight-lean"><div class="highlight"><pre><span class="kn">universes</span> <span class="n">u</span> <span class="n">v</span> <span class="n">w</span>

<span class="kn">variables</span> <span class="o">(</span><span class="n">p</span> <span class="n">q</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">)</span>
<span class="kn">variable</span>  <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span>
<span class="kn">variable</span>  <span class="o">(</span><span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span>
<span class="kn">variable</span>  <span class="o">(</span><span class="n">γ</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="n">w</span><span class="o">)</span>
<span class="kn">variable</span>  <span class="o">(</span><span class="n">η</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="n">w</span><span class="o">)</span>

<span class="kn">constants</span> <span class="n">δ</span> <span class="n">ε</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span>
<span class="kn">constants</span> <span class="n">cnst</span> <span class="o">:</span> <span class="n">δ</span>
<span class="kn">constant</span>  <span class="n">f</span> <span class="o">:</span> <span class="n">δ</span> <span class="bp">→</span> <span class="n">ε</span>

<span class="kn">variables</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">c</span> <span class="o">:</span> <span class="n">γ</span> <span class="n">a</span><span class="o">)</span> <span class="o">(</span><span class="n">d</span> <span class="o">:</span> <span class="n">δ</span><span class="o">)</span>

<span class="kn">variable</span>  <span class="n">g</span>  <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span>
<span class="kn">variable</span>  <span class="n">h</span>  <span class="o">:</span> <span class="bp">Π</span> <span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="n">γ</span> <span class="n">x</span>
<span class="kn">variable</span>  <span class="n">h&#39;</span> <span class="o">:</span> <span class="bp">Π</span> <span class="n">x</span><span class="o">,</span> <span class="n">γ</span> <span class="n">x</span> <span class="bp">→</span> <span class="n">δ</span>

<span class="bp">#</span><span class="n">check</span> <span class="kt">Sort</span> <span class="o">(</span><span class="n">u</span> <span class="bp">+</span> <span class="mi">3</span><span class="o">)</span>
<span class="bp">#</span><span class="n">check</span> <span class="kt">Prop</span>
<span class="bp">#</span><span class="n">check</span> <span class="bp">Π</span> <span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="n">γ</span> <span class="n">x</span>
<span class="bp">#</span><span class="n">check</span> <span class="n">f</span> <span class="n">cnst</span>
<span class="bp">#</span><span class="n">check</span> <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">h</span> <span class="n">x</span>
<span class="bp">#</span><span class="n">check</span> <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">h&#39;</span> <span class="n">x</span> <span class="o">(</span><span class="n">h</span> <span class="n">x</span><span class="o">)</span>
<span class="bp">#</span><span class="n">check</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">h</span> <span class="n">x</span><span class="o">)</span> <span class="n">a</span>
<span class="bp">#</span><span class="n">check</span> <span class="bp">λ</span> <span class="n">_</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">,</span> <span class="mi">5</span>
<span class="bp">#</span><span class="n">check</span> <span class="k">let</span> <span class="n">x</span> <span class="o">:=</span> <span class="n">a</span> <span class="k">in</span> <span class="n">h</span> <span class="n">x</span>

<span class="bp">#</span><span class="n">check</span> <span class="bp">Π</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="n">η</span> <span class="n">x</span> <span class="n">y</span>
<span class="bp">#</span><span class="n">check</span> <span class="bp">Π</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">β</span><span class="o">),</span> <span class="n">η</span> <span class="n">x</span> <span class="n">y</span>
<span class="bp">#</span><span class="n">check</span> <span class="bp">λ</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="n">η</span> <span class="n">x</span> <span class="n">y</span>
<span class="bp">#</span><span class="n">check</span> <span class="bp">λ</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">β</span><span class="o">),</span> <span class="n">η</span> <span class="n">x</span> <span class="n">y</span>
<span class="bp">#</span><span class="n">check</span> <span class="k">let</span> <span class="n">x</span> <span class="o">:=</span> <span class="n">a</span><span class="o">,</span> <span class="n">y</span> <span class="o">:=</span> <span class="n">b</span> <span class="k">in</span> <span class="n">η</span> <span class="n">x</span> <span class="n">y</span>

<span class="bp">#</span><span class="n">check</span> <span class="o">(</span><span class="mi">5</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span>
<span class="bp">#</span><span class="n">check</span> <span class="o">(</span><span class="mi">5</span> <span class="o">:</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">x</span><span class="o">)</span> <span class="n">ℕ</span><span class="o">)</span>
<span class="bp">#</span><span class="n">check</span> <span class="o">(</span><span class="mi">5</span> <span class="o">:</span> <span class="n">ℤ</span><span class="o">)</span>
</pre></div>
</div>
</div></div>
<div class="section" id="implicit-arguments">
<h2>Implicit Arguments<a class="headerlink" href="#implicit-arguments" title="Permalink to this headline">¶</a></h2>
<p>When declaring arguments to defined objects in Lean (for example, with <code class="docutils literal"><span class="pre">def</span></code>, <code class="docutils literal"><span class="pre">theorem</span></code>, <code class="docutils literal"><span class="pre">constant</span></code>, <code class="docutils literal"><span class="pre">inductive</span></code>, or <code class="docutils literal"><span class="pre">structure</span></code>; see <a class="reference internal" href="declarations.html"><span class="doc">Declarations</span></a>) or when declaring variables and parameters in sections (see <a class="reference internal" href="infrastructure.html"><span class="doc">Infrastructure</span></a>), arguments can be annotated as <em>explicit</em> or <em>implicit</em>. This determines how expressions containing the object are interpreted.</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">(x</span> <span class="pre">:</span> <span class="pre">α)</span></code> : an explicit argument of type <code class="docutils literal"><span class="pre">α</span></code></li>
<li><code class="docutils literal"><span class="pre">{x</span> <span class="pre">:</span> <span class="pre">α}</span></code> : an implicit argument, eagerly inserted</li>
<li><code class="docutils literal"><span class="pre">⦃x</span> <span class="pre">:</span> <span class="pre">α⦄</span></code> or <code class="docutils literal"><span class="pre">{{x</span> <span class="pre">:</span> <span class="pre">α}}</span></code> : an implicit argument, weakly inserted</li>
<li><code class="docutils literal"><span class="pre">[x</span> <span class="pre">:</span> <span class="pre">α]</span></code> : an implicit argument that should be inferred by type class resolution</li>
<li><code class="docutils literal"><span class="pre">(x</span> <span class="pre">:</span> <span class="pre">α</span> <span class="pre">:=</span> <span class="pre">t)</span></code> : an optional argument, with default value <code class="docutils literal"><span class="pre">t</span></code></li>
<li><code class="docutils literal"><span class="pre">(x</span> <span class="pre">:</span> <span class="pre">α</span> <span class="pre">.</span> <span class="pre">t)</span></code> : an implicit argument, to be synthesized by tactic <code class="docutils literal"><span class="pre">t</span></code></li>
</ul>
<p>The name of the variable can be ommitted from a class resolution argument, in which case an internal name is generated.</p>
<p>When a function has an explicit argument, you can nonetheless ask Lean’s elaborator to infer the argument automatically, by entering it as an underscore (<code class="docutils literal"><span class="pre">_</span></code>). Conversely, writing <code class="docutils literal"><span class="pre">&#64;foo</span></code> indicates that all of the arguments to be <code class="docutils literal"><span class="pre">foo</span></code> are to be given explicitly, independent of how <code class="docutils literal"><span class="pre">foo</span></code> was declared.</p>
<p><strong>Examples</strong></p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://gebner.github.io/lean-web-editor/#code=universe%20u%0A%0Adef%20ex1%20(x%20y%20z%20:%20%E2%84%95)%20:%20%E2%84%95%20:=%20x%20+%20y%20+%20z%0A%0A#check%20ex1%201%202%203%0A%0Adef%20id1%20(%CE%B1%20:%20Type%20u)%20(x%20:%20%CE%B1)%20:%20%CE%B1%20:=%20x%0A%0A#check%20id1%20nat%203%0A#check%20id1%20_%203%0A%0Adef%20id2%20%7B%CE%B1%20:%20Type%20u%7D%20(x%20:%20%CE%B1)%20:%20%CE%B1%20:=%20x%0A%0A#check%20id2%203%0A#check%20&#64;id2%20%E2%84%95%203%0A#check%20(id2%20:%20%E2%84%95%20%E2%86%92%20%E2%84%95)%0A%0Adef%20id3%20%7B%7B%CE%B1%20:%20Type%20u%7D%7D%20(x%20:%20%CE%B1)%20:%20%CE%B1%20:=%20x%0A%0A#check%20id3%203%0A#check%20&#64;id3%20%E2%84%95%203%0A#check%20(id3%20:%20%CE%A0%20%CE%B1%20:%20Type,%20%CE%B1%20%E2%86%92%20%CE%B1)%0A%0Aclass%20cls%20:=%20(val%20:%20%E2%84%95)%0Ainstance%20cls_five%20:%20cls%20:=%20%E2%9F%A85%E2%9F%A9%0A%0Adef%20ex2%20%5Bc%20:%20cls%5D%20:%20%E2%84%95%20:=%20c.val%0A%0Aexample%20:%20ex2%20=%205%20:=%20rfl%0A%0Adef%20ex2a%20%5Bcls%5D%20:%20%E2%84%95%20:=%20ex2%0A%0Aexample%20:%20ex2a%20=%205%20:=%20rfl%0A%0Adef%20ex3%20(x%20:%20%E2%84%95%20:=%205)%20:=%20x%0A%0A#check%20ex3%202%0A#check%20ex3%0Aexample%20:%20ex3%20=%205%20:=%20rfl%0A%0Ameta%20def%20ex_tac%20:%20tactic%20unit%20:=%20tactic.refine%20%60%60(5)%0A%0Adef%20ex4%20(x%20:%20%E2%84%95%20.%20ex_tac)%20:=%20x%0A%0Aexample%20:%20ex4%20=%205%20:=%20rfl" target="_blank">
try it!</a></div><div class="highlight-lean"><div class="highlight"><pre><span class="kn">universe</span> <span class="n">u</span>

<span class="kn">def</span> <span class="n">ex1</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="o">:=</span> <span class="n">x</span> <span class="bp">+</span> <span class="n">y</span> <span class="bp">+</span> <span class="n">z</span>

<span class="bp">#</span><span class="n">check</span> <span class="n">ex1</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span>

<span class="kn">def</span> <span class="n">id1</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">α</span> <span class="o">:=</span> <span class="n">x</span>

<span class="bp">#</span><span class="n">check</span> <span class="n">id1</span> <span class="n">nat</span> <span class="mi">3</span>
<span class="bp">#</span><span class="n">check</span> <span class="n">id1</span> <span class="n">_</span> <span class="mi">3</span>

<span class="kn">def</span> <span class="n">id2</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">α</span> <span class="o">:=</span> <span class="n">x</span>

<span class="bp">#</span><span class="n">check</span> <span class="n">id2</span> <span class="mi">3</span>
<span class="bp">#</span><span class="n">check</span> <span class="bp">@</span><span class="n">id2</span> <span class="n">ℕ</span> <span class="mi">3</span>
<span class="bp">#</span><span class="n">check</span> <span class="o">(</span><span class="n">id2</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">ℕ</span><span class="o">)</span>

<span class="kn">def</span> <span class="n">id3</span> <span class="o">{{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}}</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">α</span> <span class="o">:=</span> <span class="n">x</span>

<span class="bp">#</span><span class="n">check</span> <span class="n">id3</span> <span class="mi">3</span>
<span class="bp">#</span><span class="n">check</span> <span class="bp">@</span><span class="n">id3</span> <span class="n">ℕ</span> <span class="mi">3</span>
<span class="bp">#</span><span class="n">check</span> <span class="o">(</span><span class="n">id3</span> <span class="o">:</span> <span class="bp">Π</span> <span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">,</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span>

<span class="kn">class</span> <span class="n">cls</span> <span class="o">:=</span> <span class="o">(</span><span class="n">val</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span>
<span class="kn">instance</span> <span class="n">cls_five</span> <span class="o">:</span> <span class="n">cls</span> <span class="o">:=</span> <span class="o">⟨</span><span class="mi">5</span><span class="o">⟩</span>

<span class="kn">def</span> <span class="n">ex2</span> <span class="o">[</span><span class="n">c</span> <span class="o">:</span> <span class="n">cls</span><span class="o">]</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="o">:=</span> <span class="n">c</span><span class="bp">.</span><span class="n">val</span>

<span class="kn">example</span> <span class="o">:</span> <span class="n">ex2</span> <span class="bp">=</span> <span class="mi">5</span> <span class="o">:=</span> <span class="n">rfl</span>

<span class="kn">def</span> <span class="n">ex2a</span> <span class="o">[</span><span class="n">cls</span><span class="o">]</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="o">:=</span> <span class="n">ex2</span>

<span class="kn">example</span> <span class="o">:</span> <span class="n">ex2a</span> <span class="bp">=</span> <span class="mi">5</span> <span class="o">:=</span> <span class="n">rfl</span>

<span class="kn">def</span> <span class="n">ex3</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="o">:=</span> <span class="mi">5</span><span class="o">)</span> <span class="o">:=</span> <span class="n">x</span>

<span class="bp">#</span><span class="n">check</span> <span class="n">ex3</span> <span class="mi">2</span>
<span class="bp">#</span><span class="n">check</span> <span class="n">ex3</span>
<span class="kn">example</span> <span class="o">:</span> <span class="n">ex3</span> <span class="bp">=</span> <span class="mi">5</span> <span class="o">:=</span> <span class="n">rfl</span>

<span class="kn">meta</span> <span class="kn">def</span> <span class="n">ex_tac</span> <span class="o">:</span> <span class="n">tactic</span> <span class="n">unit</span> <span class="o">:=</span> <span class="n">tactic</span><span class="bp">.</span><span class="n">refine</span> <span class="bp">``</span><span class="o">(</span><span class="mi">5</span><span class="o">)</span>

<span class="kn">def</span> <span class="n">ex4</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">.</span> <span class="n">ex_tac</span><span class="o">)</span> <span class="o">:=</span> <span class="n">x</span>

<span class="kn">example</span> <span class="o">:</span> <span class="n">ex4</span> <span class="bp">=</span> <span class="mi">5</span> <span class="o">:=</span> <span class="n">rfl</span>
</pre></div>
</div>
</div></div>
<div class="section" id="basic-data-types-and-assertions">
<h2>Basic Data Types and Assertions<a class="headerlink" href="#basic-data-types-and-assertions" title="Permalink to this headline">¶</a></h2>
<p>The core library contains a numboer of basic data types, such as the natural numbers (<code class="docutils literal"><span class="pre">ℕ</span></code>, or <code class="docutils literal"><span class="pre">nat</span></code>), the integers (<code class="docutils literal"><span class="pre">ℤ</span></code>), the booleans (<code class="docutils literal"><span class="pre">bool</span></code>), and common operations on these, as well as the usual logical quantifiers and connectives. Some example are given below. A list of common notations and their precedences can be found in a <a class="reference external" href="https://github.com/leanprover/lean/blob/master/library/init/core.lean">file</a> in the core library. The core library also contains a number of basic data type constructors. Definitions can also be found the <a class="reference external" href="https://github.com/leanprover/lean/blob/master/library/init/data">data</a> directory of the core library. For more information, see also <a class="reference internal" href="libraries.html"><span class="doc">Libraries</span></a>.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://gebner.github.io/lean-web-editor/#code=/-%20numbers%20-/%0Asection%0Avariables%20a%20b%20c%20d%20:%20%E2%84%95%0Avariables%20i%20j%20k%20:%20%E2%84%A4%0A%0A#check%20a%5E2%20+%20b%5E2%20+%20c%5E2%0A#check%20(a%20+%20b)%5Ec%20%E2%89%A4%20d%0A#check%20i%20%E2%88%A3%20j%20*%20k%0Aend%0A%0A/-%20booleans%20-/%0Asection%0Avariables%20a%20b%20c%20:%20bool%0A%0A#check%20a%20&amp;&amp;%20(b%20%7C%7C%20c)%0Aend%0A%0A/-%20pairs%20-/%0Asection%0Avariables%20(a%20b%20c%20:%20%E2%84%95)%20(p%20:%20%E2%84%95%20%C3%97%20bool)%0A%0A#check%20(1,%202)%0A#check%20p.1%20*%202%0A#check%20p.2%20&amp;&amp;%20tt%0A#check%20((1,%202,%203)%20:%20%E2%84%95%20%C3%97%20%E2%84%95%20%C3%97%20%E2%84%95)%0Aend%0A%0A/-%20lists%20-/%0Asection%0Avariables%20x%20y%20z%20:%20%E2%84%95%0Avariables%20xs%20ys%20zs%20:%20list%20%E2%84%95%0Aopen%20list%0A%0A#check%20(1%20::%20xs)%20++%20(y%20::%20zs)%20++%20%5B1,2,3%5D%0A#check%20append%20(cons%201%20xs)%20(cons%20y%20zs)%0A#check%20map%20(%CE%BB%20x,%20x%5E2)%20%5B1,%202,%203%5D%0Aend%0A%0A/-%20sets%20-/%0Asection%0Avariables%20s%20t%20u%20:%20set%20%E2%84%95%0A%0A#check%20(%7B1,%202,%203%7D%20%E2%88%A9%20s)%20%E2%88%AA%20(%7Bx%20%7C%20x%20%3C%207%7D%20%E2%88%A9%20t)%0Aend%0A%0A/-%20strings%20and%20characters%20-/%0A#check%20%22hello%20world%22%0A#check%20'a'%0A%0A/-%20assertions%20-/%0A#check%20%E2%88%80%20a%20b%20c%20n%20:%20%E2%84%95,%20a%20%E2%89%A0%200%20%E2%88%A7%20b%20%E2%89%A0%200%20%E2%88%A7%20c%20%E2%89%A0%200%20%E2%88%A7%20n%20%3E%202%20%E2%86%92%20a%5En%20+%20b%5En%20%E2%89%A0%20c%5En%0Adef%20unbounded%20(f%20:%20%E2%84%95%20%E2%86%92%20%E2%84%95)%20:%20Prop%20:=%20%E2%88%80%20M,%20%E2%88%83%20n,%20f%20n%20%E2%89%A5%20M" target="_blank">
try it!</a></div><div class="highlight-lean"><div class="highlight"><pre><span class="c">/-</span><span class="cm"> numbers -/</span>
<span class="kn">section</span>
<span class="kn">variables</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="n">d</span> <span class="o">:</span> <span class="n">ℕ</span>
<span class="kn">variables</span> <span class="n">i</span> <span class="n">j</span> <span class="n">k</span> <span class="o">:</span> <span class="n">ℤ</span>

<span class="bp">#</span><span class="n">check</span> <span class="n">a</span><span class="bp">^</span><span class="mi">2</span> <span class="bp">+</span> <span class="n">b</span><span class="bp">^</span><span class="mi">2</span> <span class="bp">+</span> <span class="n">c</span><span class="bp">^</span><span class="mi">2</span>
<span class="bp">#</span><span class="n">check</span> <span class="o">(</span><span class="n">a</span> <span class="bp">+</span> <span class="n">b</span><span class="o">)</span><span class="bp">^</span><span class="n">c</span> <span class="bp">≤</span> <span class="n">d</span>
<span class="bp">#</span><span class="n">check</span> <span class="n">i</span> <span class="bp">∣</span> <span class="n">j</span> <span class="bp">*</span> <span class="n">k</span>
<span class="k">end</span>

<span class="c">/-</span><span class="cm"> booleans -/</span>
<span class="kn">section</span>
<span class="kn">variables</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">:</span> <span class="n">bool</span>

<span class="bp">#</span><span class="n">check</span> <span class="n">a</span> <span class="bp">&amp;&amp;</span> <span class="o">(</span><span class="n">b</span> <span class="bp">||</span> <span class="n">c</span><span class="o">)</span>
<span class="k">end</span>

<span class="c">/-</span><span class="cm"> pairs -/</span>
<span class="kn">section</span>
<span class="kn">variables</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">×</span> <span class="n">bool</span><span class="o">)</span>

<span class="bp">#</span><span class="n">check</span> <span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">)</span>
<span class="bp">#</span><span class="n">check</span> <span class="n">p</span><span class="bp">.</span><span class="mi">1</span> <span class="bp">*</span> <span class="mi">2</span>
<span class="bp">#</span><span class="n">check</span> <span class="n">p</span><span class="bp">.</span><span class="mi">2</span> <span class="bp">&amp;&amp;</span> <span class="n">tt</span>
<span class="bp">#</span><span class="n">check</span> <span class="o">((</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">×</span> <span class="n">ℕ</span> <span class="bp">×</span> <span class="n">ℕ</span><span class="o">)</span>
<span class="k">end</span>

<span class="c">/-</span><span class="cm"> lists -/</span>
<span class="kn">section</span>
<span class="kn">variables</span> <span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="o">:</span> <span class="n">ℕ</span>
<span class="kn">variables</span> <span class="n">xs</span> <span class="n">ys</span> <span class="n">zs</span> <span class="o">:</span> <span class="n">list</span> <span class="n">ℕ</span>
<span class="kn">open</span> <span class="n">list</span>

<span class="bp">#</span><span class="n">check</span> <span class="o">(</span><span class="mi">1</span> <span class="o">::</span> <span class="n">xs</span><span class="o">)</span> <span class="bp">++</span> <span class="o">(</span><span class="n">y</span> <span class="o">::</span> <span class="n">zs</span><span class="o">)</span> <span class="bp">++</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">]</span>
<span class="bp">#</span><span class="n">check</span> <span class="n">append</span> <span class="o">(</span><span class="n">cons</span> <span class="mi">1</span> <span class="n">xs</span><span class="o">)</span> <span class="o">(</span><span class="n">cons</span> <span class="n">y</span> <span class="n">zs</span><span class="o">)</span>
<span class="bp">#</span><span class="n">check</span> <span class="n">map</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">x</span><span class="bp">^</span><span class="mi">2</span><span class="o">)</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">]</span>
<span class="k">end</span>

<span class="c">/-</span><span class="cm"> sets -/</span>
<span class="kn">section</span>
<span class="kn">variables</span> <span class="n">s</span> <span class="n">t</span> <span class="n">u</span> <span class="o">:</span> <span class="n">set</span> <span class="n">ℕ</span>

<span class="bp">#</span><span class="n">check</span> <span class="o">({</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">}</span> <span class="bp">∩</span> <span class="n">s</span><span class="o">)</span> <span class="bp">∪</span> <span class="o">({</span><span class="n">x</span> <span class="bp">|</span> <span class="n">x</span> <span class="bp">&lt;</span> <span class="mi">7</span><span class="o">}</span> <span class="bp">∩</span> <span class="n">t</span><span class="o">)</span>
<span class="k">end</span>

<span class="c">/-</span><span class="cm"> strings and characters -/</span>
<span class="bp">#</span><span class="n">check</span> <span class="s2">&quot;hello world&quot;</span>
<span class="bp">#</span><span class="n">check</span> <span class="bp">&#39;</span><span class="n">a&#39;</span>

<span class="c">/-</span><span class="cm"> assertions -/</span>
<span class="bp">#</span><span class="n">check</span> <span class="bp">∀</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="n">n</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">,</span> <span class="n">a</span> <span class="bp">≠</span> <span class="mi">0</span> <span class="bp">∧</span> <span class="n">b</span> <span class="bp">≠</span> <span class="mi">0</span> <span class="bp">∧</span> <span class="n">c</span> <span class="bp">≠</span> <span class="mi">0</span> <span class="bp">∧</span> <span class="n">n</span> <span class="bp">&gt;</span> <span class="mi">2</span> <span class="bp">→</span> <span class="n">a</span><span class="bp">^</span><span class="n">n</span> <span class="bp">+</span> <span class="n">b</span><span class="bp">^</span><span class="n">n</span> <span class="bp">≠</span> <span class="n">c</span><span class="bp">^</span><span class="n">n</span>
<span class="kn">def</span> <span class="n">unbounded</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="bp">∀</span> <span class="n">M</span><span class="o">,</span> <span class="bp">∃</span> <span class="n">n</span><span class="o">,</span> <span class="n">f</span> <span class="n">n</span> <span class="bp">≥</span> <span class="n">M</span>
</pre></div>
</div>
</div></div>
<div class="section" id="constructors-projections-and-matching">
<span id="id2"></span><h2>Constructors, Projections, and Matching<a class="headerlink" href="#constructors-projections-and-matching" title="Permalink to this headline">¶</a></h2>
<p>Lean foundation, the <em>Calculus of Inductive Constructions</em>, supports the declaration of <em>inductive types</em>. Such types can have any number of <em>constructors</em>, and an associated <em>eliminator</em> (or <em>recursor</em>). Inductive types with one constructor, known as <em>structures</em>, have <em>projections</em>. The full syntax of inductive types is described in <a class="reference internal" href="declarations.html"><span class="doc">Declarations</span></a>, but here we describe some syntactic elements that facilitate their use in expressions.</p>
<p>When Lean can infer the type of an expression and it is an inductive type with one constructor, then one can write <code class="docutils literal"><span class="pre">⟨a1,</span> <span class="pre">a2,</span> <span class="pre">...,</span> <span class="pre">an⟩</span></code> to apply the constructor without naming it. For example, <code class="docutils literal"><span class="pre">⟨a,</span> <span class="pre">b⟩</span></code> denotes <code class="docutils literal"><span class="pre">prod.mk</span> <span class="pre">a</span> <span class="pre">b</span></code> in a context where the expression can be inferred to be a pair, and <code class="docutils literal"><span class="pre">⟨h₁,</span> <span class="pre">h₂⟩</span></code> denotes <code class="docutils literal"><span class="pre">and.intro</span> <span class="pre">h₁</span> <span class="pre">h₂</span></code> in a context when the expression can be inferred to be a conjunction. The notation will nest constructions automatically, so <code class="docutils literal"><span class="pre">⟨a1,</span> <span class="pre">a2,</span> <span class="pre">a3⟩</span></code> is interpreted as <code class="docutils literal"><span class="pre">prod.mk</span> <span class="pre">a1</span> <span class="pre">(prod.mk</span> <span class="pre">a2</span> <span class="pre">a3)</span></code> when the expression is expected to have a type of the form <code class="docutils literal"><span class="pre">α1</span> <span class="pre">×</span> <span class="pre">α2</span> <span class="pre">×</span> <span class="pre">α3</span></code>. (The latter is interpreted as <code class="docutils literal"><span class="pre">α1</span> <span class="pre">×</span> <span class="pre">(α2</span> <span class="pre">×</span> <span class="pre">α3)</span></code>, since the product associates to the right.)</p>
<p>Similarly, one can use “dot notation” for projections: one can write <code class="docutils literal"><span class="pre">p.fst</span></code> and <code class="docutils literal"><span class="pre">p.snd</span></code> for <code class="docutils literal"><span class="pre">prod.fst</span> <span class="pre">p</span></code> and <code class="docutils literal"><span class="pre">prod.snd</span> <span class="pre">p</span></code> when Lean can infer that <code class="docutils literal"><span class="pre">p</span></code> is an element of a product, and <code class="docutils literal"><span class="pre">h.left</span></code> and <code class="docutils literal"><span class="pre">h.right</span></code> for <code class="docutils literal"><span class="pre">and.left</span> <span class="pre">h</span></code> and <code class="docutils literal"><span class="pre">and.right</span> <span class="pre">h</span></code> when <code class="docutils literal"><span class="pre">h</span></code> is a conjunction.</p>
<p>The anonymous projector notation can used more generally for any objects defined in a <em>namespace</em> (see <a class="reference internal" href="infrastructure.html"><span class="doc">Infrastructure</span></a>). For example, if <code class="docutils literal"><span class="pre">l</span></code> has type <code class="docutils literal"><span class="pre">list</span> <span class="pre">α</span></code> then <code class="docutils literal"><span class="pre">l.map</span> <span class="pre">f</span></code> abbreviates <code class="docutils literal"><span class="pre">list.map</span> <span class="pre">f</span> <span class="pre">l</span></code>, in which <code class="docutils literal"><span class="pre">l</span></code> has been placed at the first argument position where <code class="docutils literal"><span class="pre">list.map</span></code> expects a <code class="docutils literal"><span class="pre">list</span></code>.</p>
<p>Finally, for data types with one constructor, one destruct an element by pattern matching using the <code class="docutils literal"><span class="pre">let</span></code> and <code class="docutils literal"><span class="pre">assume</span></code> constructs, as in the examples below. Internally, these are interpreted using the <code class="docutils literal"><span class="pre">match</span></code> construct, which is in turn compiled down for the eliminator for the inductive type, as described in <a class="reference internal" href="declarations.html"><span class="doc">Declarations</span></a>.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://gebner.github.io/lean-web-editor/#code=universes%20u%20v%0Avariables%20%7B%CE%B1%20:%20Type%20u%7D%20%7B%CE%B2%20:%20Type%20v%7D%0A%0Adef%20p%20:%20%E2%84%95%20%C3%97%20%E2%84%A4%20:=%20%E2%9F%A81,%202%E2%9F%A9%0A#check%20p.fst%0A#check%20p.snd%0A%0Adef%20p'%20:%20%E2%84%95%20%C3%97%20%E2%84%A4%20%C3%97%20bool%20:=%20%E2%9F%A81,%202,%20tt%E2%9F%A9%0A#check%20p'.fst%0A#check%20p'.snd.fst%0A#check%20p'.snd.snd%0A%0Adef%20swap_pair%20(p%20:%20%CE%B1%20%C3%97%20%CE%B2)%20:%20%CE%B2%20%C3%97%20%CE%B1%20:=%0A%E2%9F%A8p.snd,%20p.fst%E2%9F%A9%0A%0Atheorem%20swap_conj%20%7Ba%20b%20:%20Prop%7D%20(h%20:%20a%20%E2%88%A7%20b)%20:%20b%20%E2%88%A7%20a%20:=%0A%E2%9F%A8h.right,%20h.left%E2%9F%A9%0A%0A#check%20%5B1,%202,%203%5D.append%20%5B2,%203,%204%5D%0A#check%20%5B1,%202,%203%5D.map%20(%CE%BB%20x,%20x%5E2)%0A%0Aexample%20(p%20q%20:%20Prop)%20:%20p%20%E2%88%A7%20q%20%E2%86%92%20q%20%E2%88%A7%20p%20:=%0A%CE%BB%20h,%20%E2%9F%A8h.right,%20h.left%E2%9F%A9%0A%0Adef%20swap_pair'%20(p%20:%20%CE%B1%20%C3%97%20%CE%B2)%20:%20%CE%B2%20%C3%97%20%CE%B1%20:=%0Alet%20(x,%20y)%20:=%20p%20in%20(y,%20x)%0A%0Atheorem%20swap_conj'%20%7Ba%20b%20:%20Prop%7D%20(h%20:%20a%20%E2%88%A7%20b)%20:%20b%20%E2%88%A7%20a%20:=%0Alet%20%E2%9F%A8ha,%20hb%E2%9F%A9%20:=%20h%20in%20%E2%9F%A8hb,%20ha%E2%9F%A9%0A%0Adef%20swap_pair''%20:%20%CE%B1%20%C3%97%20%CE%B2%20%E2%86%92%20%CE%B2%20%C3%97%20%CE%B1%20:=%0A%CE%BB%20%E2%9F%A8x,%20y%E2%9F%A9,%20(y,%20x)%0A%0Atheorem%20swap_conj''%20%7Ba%20b%20:%20Prop%7D%20:%20a%20%E2%88%A7%20b%20%E2%86%92%20b%20%E2%88%A7%20a%20:=%0Aassume%20%E2%9F%A8ha,%20hb%E2%9F%A9,%20%E2%9F%A8hb,%20ha%E2%9F%A9" target="_blank">
try it!</a></div><div class="highlight-lean"><div class="highlight"><pre><span class="kn">universes</span> <span class="n">u</span> <span class="n">v</span>
<span class="kn">variables</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">{</span><span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">}</span>

<span class="kn">def</span> <span class="n">p</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">×</span> <span class="n">ℤ</span> <span class="o">:=</span> <span class="o">⟨</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">⟩</span>
<span class="bp">#</span><span class="n">check</span> <span class="n">p</span><span class="bp">.</span><span class="n">fst</span>
<span class="bp">#</span><span class="n">check</span> <span class="n">p</span><span class="bp">.</span><span class="n">snd</span>

<span class="kn">def</span> <span class="n">p&#39;</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">×</span> <span class="n">ℤ</span> <span class="bp">×</span> <span class="n">bool</span> <span class="o">:=</span> <span class="o">⟨</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="n">tt</span><span class="o">⟩</span>
<span class="bp">#</span><span class="n">check</span> <span class="n">p&#39;</span><span class="bp">.</span><span class="n">fst</span>
<span class="bp">#</span><span class="n">check</span> <span class="n">p&#39;</span><span class="bp">.</span><span class="n">snd</span><span class="bp">.</span><span class="n">fst</span>
<span class="bp">#</span><span class="n">check</span> <span class="n">p&#39;</span><span class="bp">.</span><span class="n">snd</span><span class="bp">.</span><span class="n">snd</span>

<span class="kn">def</span> <span class="n">swap_pair</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">×</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span> <span class="n">β</span> <span class="bp">×</span> <span class="n">α</span> <span class="o">:=</span>
<span class="o">⟨</span><span class="n">p</span><span class="bp">.</span><span class="n">snd</span><span class="o">,</span> <span class="n">p</span><span class="bp">.</span><span class="n">fst</span><span class="o">⟩</span>

<span class="kn">theorem</span> <span class="n">swap_conj</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">∧</span> <span class="n">b</span><span class="o">)</span> <span class="o">:</span> <span class="n">b</span> <span class="bp">∧</span> <span class="n">a</span> <span class="o">:=</span>
<span class="o">⟨</span><span class="n">h</span><span class="bp">.</span><span class="n">right</span><span class="o">,</span> <span class="n">h</span><span class="bp">.</span><span class="n">left</span><span class="o">⟩</span>

<span class="bp">#</span><span class="n">check</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">]</span><span class="bp">.</span><span class="n">append</span> <span class="o">[</span><span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">]</span>
<span class="bp">#</span><span class="n">check</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">]</span><span class="bp">.</span><span class="n">map</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">x</span><span class="bp">^</span><span class="mi">2</span><span class="o">)</span>

<span class="kn">example</span> <span class="o">(</span><span class="n">p</span> <span class="n">q</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">∧</span> <span class="n">q</span> <span class="bp">→</span> <span class="n">q</span> <span class="bp">∧</span> <span class="n">p</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">h</span><span class="o">,</span> <span class="o">⟨</span><span class="n">h</span><span class="bp">.</span><span class="n">right</span><span class="o">,</span> <span class="n">h</span><span class="bp">.</span><span class="n">left</span><span class="o">⟩</span>

<span class="kn">def</span> <span class="n">swap_pair&#39;</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">×</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span> <span class="n">β</span> <span class="bp">×</span> <span class="n">α</span> <span class="o">:=</span>
<span class="k">let</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span> <span class="o">:=</span> <span class="n">p</span> <span class="k">in</span> <span class="o">(</span><span class="n">y</span><span class="o">,</span> <span class="n">x</span><span class="o">)</span>

<span class="kn">theorem</span> <span class="n">swap_conj&#39;</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">∧</span> <span class="n">b</span><span class="o">)</span> <span class="o">:</span> <span class="n">b</span> <span class="bp">∧</span> <span class="n">a</span> <span class="o">:=</span>
<span class="k">let</span> <span class="o">⟨</span><span class="n">ha</span><span class="o">,</span> <span class="n">hb</span><span class="o">⟩</span> <span class="o">:=</span> <span class="n">h</span> <span class="k">in</span> <span class="o">⟨</span><span class="n">hb</span><span class="o">,</span> <span class="n">ha</span><span class="o">⟩</span>

<span class="kn">def</span> <span class="n">swap_pair&#39;&#39;</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">×</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">β</span> <span class="bp">×</span> <span class="n">α</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="o">⟨</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">⟩,</span> <span class="o">(</span><span class="n">y</span><span class="o">,</span> <span class="n">x</span><span class="o">)</span>

<span class="kn">theorem</span> <span class="n">swap_conj&#39;&#39;</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">}</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">∧</span> <span class="n">b</span> <span class="bp">→</span> <span class="n">b</span> <span class="bp">∧</span> <span class="n">a</span> <span class="o">:=</span>
<span class="k">assume</span> <span class="o">⟨</span><span class="n">ha</span><span class="o">,</span> <span class="n">hb</span><span class="o">⟩,</span> <span class="o">⟨</span><span class="n">hb</span><span class="o">,</span> <span class="n">ha</span><span class="o">⟩</span>
</pre></div>
</div>
</div></div>
<div class="section" id="structured-proofs">
<span id="id3"></span><h2>Structured Proofs<a class="headerlink" href="#structured-proofs" title="Permalink to this headline">¶</a></h2>
<p>Syntactic sugar is provided for writing structured proof terms:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">assume</span> <span class="pre">h</span> <span class="pre">:</span> <span class="pre">p,</span> <span class="pre">t</span></code> is sugar for <code class="docutils literal"><span class="pre">λ</span> <span class="pre">h</span> <span class="pre">:</span> <span class="pre">p,</span> <span class="pre">t</span></code></li>
<li><code class="docutils literal"><span class="pre">have</span> <span class="pre">h</span> <span class="pre">:</span> <span class="pre">p,</span> <span class="pre">from</span> <span class="pre">s,</span> <span class="pre">t</span></code> is sugar for <code class="docutils literal"><span class="pre">(λ</span> <span class="pre">h</span> <span class="pre">:</span> <span class="pre">p,</span> <span class="pre">t)</span> <span class="pre">s</span></code></li>
<li><code class="docutils literal"><span class="pre">suffices</span> <span class="pre">h</span> <span class="pre">:</span> <span class="pre">p,</span> <span class="pre">from</span> <span class="pre">s,</span> <span class="pre">t</span></code> is sugar for <code class="docutils literal"><span class="pre">(λ</span> <span class="pre">h</span> <span class="pre">:</span> <span class="pre">p,</span> <span class="pre">s)</span> <span class="pre">t</span></code></li>
<li><code class="docutils literal"><span class="pre">show</span> <span class="pre">p,</span> <span class="pre">t</span></code> is sugar for <code class="docutils literal"><span class="pre">(t</span> <span class="pre">:</span> <span class="pre">p)</span></code></li>
</ul>
<p>As with <code class="docutils literal"><span class="pre">λ</span></code>, multiple variables can be bound with <code class="docutils literal"><span class="pre">assume</span></code>, and types can be ommitted when they can be inferred by Lean. Lean also allows the syntax <code class="docutils literal"><span class="pre">assume</span> <span class="pre">:</span> <span class="pre">p,</span> <span class="pre">t</span></code>, which gives the assumption the name <code class="docutils literal"><span class="pre">this</span></code> in the local context.  Similarly, Lean recognizes the variants <code class="docutils literal"><span class="pre">have</span> <span class="pre">p,</span> <span class="pre">from</span> <span class="pre">s,</span> <span class="pre">t</span></code> and <code class="docutils literal"><span class="pre">suffices</span> <span class="pre">p,</span> <span class="pre">from</span> <span class="pre">s,</span> <span class="pre">t</span></code>, which use the name <code class="docutils literal"><span class="pre">this</span></code> for the new hypothesis.</p>
<p>The notation <code class="docutils literal"><span class="pre">‹p›</span></code> is notation for <code class="docutils literal"><span class="pre">(by</span> <span class="pre">assumption</span> <span class="pre">:</span> <span class="pre">p)</span></code>, and can therefore be used to apply hypotheses in the local context.</p>
<p>As noted in <a class="reference internal" href="#constructors-projections-and-matching"><span class="std std-ref">Constructors, Projections, and Matching</span></a>, anonymous constructors and projections and match syntax can be used in proofs just as in expressions that denote data.</p>
<p><strong>Examples</strong></p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://gebner.github.io/lean-web-editor/#code=example%20(p%20q%20r%20:%20Prop)%20:%20p%20%E2%86%92%20(q%20%E2%88%A7%20r)%20%E2%86%92%20p%20%E2%88%A7%20q%20:=%0Aassume%20h%E2%82%81%20:%20p,%0Aassume%20h%E2%82%82%20:%20q%20%E2%88%A7%20r,%0Ahave%20h%E2%82%83%20:%20q,%20from%20and.left%20h%E2%82%82,%0Ashow%20p%20%E2%88%A7%20q,%20from%20and.intro%20h%E2%82%81%20h%E2%82%83%0A%0Aexample%20(p%20q%20r%20:%20Prop)%20:%20p%20%E2%86%92%20(q%20%E2%88%A7%20r)%20%E2%86%92%20p%20%E2%88%A7%20q%20:=%0Aassume%20:%20p,%0Aassume%20:%20q%20%E2%88%A7%20r,%0Ahave%20q,%20from%20and.left%20this,%0Ashow%20p%20%E2%88%A7%20q,%20from%20and.intro%20%E2%80%B9p%E2%80%BA%20this%0A%0Aexample%20(p%20q%20r%20:%20Prop)%20:%20p%20%E2%86%92%20(q%20%E2%88%A7%20r)%20%E2%86%92%20p%20%E2%88%A7%20q%20:=%0Aassume%20h%E2%82%81%20:%20p,%0Aassume%20h%E2%82%82%20:%20q%20%E2%88%A7%20r,%0Asuffices%20h%E2%82%83%20:%20q,%20from%20and.intro%20h%E2%82%81%20h%E2%82%83,%0Ashow%20q,%20from%20and.left%20h%E2%82%82" target="_blank">
try it!</a></div><div class="highlight-lean"><div class="highlight"><pre><span class="kn">example</span> <span class="o">(</span><span class="n">p</span> <span class="n">q</span> <span class="n">r</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">→</span> <span class="o">(</span><span class="n">q</span> <span class="bp">∧</span> <span class="n">r</span><span class="o">)</span> <span class="bp">→</span> <span class="n">p</span> <span class="bp">∧</span> <span class="n">q</span> <span class="o">:=</span>
<span class="k">assume</span> <span class="n">h₁</span> <span class="o">:</span> <span class="n">p</span><span class="o">,</span>
<span class="k">assume</span> <span class="n">h₂</span> <span class="o">:</span> <span class="n">q</span> <span class="bp">∧</span> <span class="n">r</span><span class="o">,</span>
<span class="k">have</span> <span class="n">h₃</span> <span class="o">:</span> <span class="n">q</span><span class="o">,</span> <span class="k">from</span> <span class="n">and</span><span class="bp">.</span><span class="n">left</span> <span class="n">h₂</span><span class="o">,</span>
<span class="k">show</span> <span class="n">p</span> <span class="bp">∧</span> <span class="n">q</span><span class="o">,</span> <span class="k">from</span> <span class="n">and</span><span class="bp">.</span><span class="n">intro</span> <span class="n">h₁</span> <span class="n">h₃</span>

<span class="kn">example</span> <span class="o">(</span><span class="n">p</span> <span class="n">q</span> <span class="n">r</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">→</span> <span class="o">(</span><span class="n">q</span> <span class="bp">∧</span> <span class="n">r</span><span class="o">)</span> <span class="bp">→</span> <span class="n">p</span> <span class="bp">∧</span> <span class="n">q</span> <span class="o">:=</span>
<span class="k">assume</span> <span class="o">:</span> <span class="n">p</span><span class="o">,</span>
<span class="k">assume</span> <span class="o">:</span> <span class="n">q</span> <span class="bp">∧</span> <span class="n">r</span><span class="o">,</span>
<span class="k">have</span> <span class="n">q</span><span class="o">,</span> <span class="k">from</span> <span class="n">and</span><span class="bp">.</span><span class="n">left</span> <span class="k">this</span><span class="o">,</span>
<span class="k">show</span> <span class="n">p</span> <span class="bp">∧</span> <span class="n">q</span><span class="o">,</span> <span class="k">from</span> <span class="n">and</span><span class="bp">.</span><span class="n">intro</span> <span class="o">‹</span><span class="n">p</span><span class="o">›</span> <span class="k">this</span>

<span class="kn">example</span> <span class="o">(</span><span class="n">p</span> <span class="n">q</span> <span class="n">r</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">:</span> <span class="n">p</span> <span class="bp">→</span> <span class="o">(</span><span class="n">q</span> <span class="bp">∧</span> <span class="n">r</span><span class="o">)</span> <span class="bp">→</span> <span class="n">p</span> <span class="bp">∧</span> <span class="n">q</span> <span class="o">:=</span>
<span class="k">assume</span> <span class="n">h₁</span> <span class="o">:</span> <span class="n">p</span><span class="o">,</span>
<span class="k">assume</span> <span class="n">h₂</span> <span class="o">:</span> <span class="n">q</span> <span class="bp">∧</span> <span class="n">r</span><span class="o">,</span>
<span class="k">suffices</span> <span class="n">h₃</span> <span class="o">:</span> <span class="n">q</span><span class="o">,</span> <span class="k">from</span> <span class="n">and</span><span class="bp">.</span><span class="n">intro</span> <span class="n">h₁</span> <span class="n">h₃</span><span class="o">,</span>
<span class="k">show</span> <span class="n">q</span><span class="o">,</span> <span class="k">from</span> <span class="n">and</span><span class="bp">.</span><span class="n">left</span> <span class="n">h₂</span>
</pre></div>
</div>
</div></div>
<div class="section" id="computation">
<h2>Computation<a class="headerlink" href="#computation" title="Permalink to this headline">¶</a></h2>
<p>Two expressions that differ up to a renaming of their bound variables are said to be <em>α-equivalent</em>, and are treated as syntactically equivalent by Lean.</p>
<p>Every expression in Lean has a natural computational interpretation, unless it involves classical elements that block computation, as described in the next section. The system recognizes the following notions of <em>reduction</em>:</p>
<ul class="simple">
<li><em>β-reduction</em> : An expression <code class="docutils literal"><span class="pre">(λ</span> <span class="pre">x,</span> <span class="pre">t)</span> <span class="pre">s</span></code> β-reduces to <code class="docutils literal"><span class="pre">t[s/x]</span></code>, that is, the result of replacing <code class="docutils literal"><span class="pre">x</span></code> by <code class="docutils literal"><span class="pre">s</span></code> in <code class="docutils literal"><span class="pre">t</span></code>.</li>
<li><em>ζ-reduction</em> : An expression <code class="docutils literal"><span class="pre">let</span> <span class="pre">x</span> <span class="pre">:=</span> <span class="pre">s</span> <span class="pre">in</span> <span class="pre">t</span></code> ζ-reduces to <code class="docutils literal"><span class="pre">t[s/x]</span></code>.</li>
<li><em>δ-reduction</em> : If <code class="docutils literal"><span class="pre">c</span></code> is a defined constant with definition <code class="docutils literal"><span class="pre">t</span></code>, then <code class="docutils literal"><span class="pre">c</span></code> δ-reduces to to <code class="docutils literal"><span class="pre">t</span></code>.</li>
<li><em>ι-reduction</em> : When a function defined by recursion on an inductive type is applied to an element given by an explicit constructor, the result ι-reduces to the specified function value, as described in <a class="reference internal" href="declarations.html#inductive-definitions"><span class="std std-ref">Inductive Definitions</span></a>.</li>
</ul>
<p>The reduction relation is transitive, which is to say, is <code class="docutils literal"><span class="pre">s</span></code> reduces to <code class="docutils literal"><span class="pre">s'</span></code> and <code class="docutils literal"><span class="pre">t</span></code> reduces to <code class="docutils literal"><span class="pre">t'</span></code>, then <code class="docutils literal"><span class="pre">s</span> <span class="pre">t</span></code> reduces to <code class="docutils literal"><span class="pre">s'</span> <span class="pre">t'</span></code>, <code class="docutils literal"><span class="pre">λ</span> <span class="pre">x,</span> <span class="pre">s</span></code> reduces to <code class="docutils literal"><span class="pre">λ</span> <span class="pre">x,</span> <span class="pre">s'</span></code>, and so on. If <code class="docutils literal"><span class="pre">s</span></code> and <code class="docutils literal"><span class="pre">t</span></code> reduce to a common term, they are said to be <em>definitionally equal</em>. Definitional equality is defined to be the smallest equivalence relation that satisfies all these properties and also includes α-equivalenece and the following two relations:</p>
<ul class="simple">
<li><em>η-equivalence</em> : An expression <code class="docutils literal"><span class="pre">(λx,</span> <span class="pre">t</span> <span class="pre">x)</span></code> is η-equivalent to <code class="docutils literal"><span class="pre">t</span></code>, assuming <code class="docutils literal"><span class="pre">x</span></code> does not occur in <code class="docutils literal"><span class="pre">t</span></code>.</li>
<li><em>proof irrelevance</em> : If <code class="docutils literal"><span class="pre">p</span> <span class="pre">:</span> <span class="pre">Prop</span></code>, <code class="docutils literal"><span class="pre">s</span> <span class="pre">:</span> <span class="pre">p</span></code>, and <code class="docutils literal"><span class="pre">t</span> <span class="pre">:</span> <span class="pre">p</span></code>, then <code class="docutils literal"><span class="pre">s</span></code> and <code class="docutils literal"><span class="pre">t</span></code> are  considered to be equivalent.</li>
</ul>
<p>This last fact reflects the intuition that once we have proved a proposition <code class="docutils literal"><span class="pre">p</span></code>, we only care that is has been proved; the proof does nothing more than witness the fact that <code class="docutils literal"><span class="pre">p</span></code> is true.</p>
<p>Definitional equality is a strong notion of equalty of values. Lean’s logical foundations sanction treating definitionally equal terms as being the same when checking that a term is well-typed and/or that it has a given type.</p>
<p>The reduction relation is believed to be strongly normalizing, which is to say, every sequence of reductions applied to a term will eventually terminate. The property guarantees that Lean’s type-checking algorithm terminates, at least in principle. The consistency of Lean and its soundness with respect to a set-theoretic semantics do not depend on either of these properties.</p>
<p>Lean provides two commands to compute with expressions:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">#reduce</span> <span class="pre">t</span></code> : use the kernel type-checking procedures to carry out reductions on <code class="docutils literal"><span class="pre">t</span></code> until no more reductions are possible, and show the result</li>
<li><code class="docutils literal"><span class="pre">#eval</span> <span class="pre">t</span></code> : evaluate <code class="docutils literal"><span class="pre">t</span></code> using a fast bytecode evalator, and show the result</li>
</ul>
<p>Every computable definition in Lean is compiled to bytecode at definition time. Bytecode evaluation is more liberal than kernel evaluation: types and all propositional information are erased, and functions are evaluated using a stack-based virtual machine. As a result, <code class="docutils literal"><span class="pre">#eval</span></code> is more efficient than <code class="docutils literal"><span class="pre">#reduce,</span></code> and can be used to execute complex programs. In contrast, <code class="docutils literal"><span class="pre">#reduce</span></code> is designed to be small and reliable, and to produce type-correct terms at each step. Bytecode is never used in type checking, so as far as soundness and consistency are concerned, only kernel reduction is part of the trusted computing base.</p>
<p><strong>Examples</strong></p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://gebner.github.io/lean-web-editor/#code=#reduce%20(%CE%BB%20x,%20x%20+%203)%205%0A#eval%20%20%20(%CE%BB%20x,%20x%20+%203)%205%0A%0A#reduce%20let%20x%20:=%205%20in%20x%20+%203%0A#eval%20%20%20let%20x%20:=%205%20in%20x%20+%203%0A%0Adef%20f%20x%20:=%20x%20+%203%0A%0A#reduce%20f%205%0A#eval%20%20%20f%205%0A%0A#reduce%20&#64;nat.rec%20(%CE%BB%20n,%20%E2%84%95)%20(0%20:%20%E2%84%95)%20(%CE%BB%20n%20recval%20:%20%E2%84%95,%20recval%20+%20n%20+%201)%20(5%20:%20%E2%84%95)%0A#eval%20%20%20&#64;nat.rec%20(%CE%BB%20n,%20%E2%84%95)%20(0%20:%20%E2%84%95)%20(%CE%BB%20n%20recval%20:%20%E2%84%95,%20recval%20+%20n%20+%201)%20(5%20:%20%E2%84%95)%0A%0Adef%20g%20:%20%E2%84%95%20%E2%86%92%20%E2%84%95%0A%7C%200%20%20%20%20%20:=%200%0A%7C%20(n+1)%20:=%20g%20n%20+%20n%20+%201%0A%0A#reduce%20g%205%0A#eval%20%20%20g%205%0A%0A#eval%20%20%20g%2050000%0A%0Aexample%20:%20(%CE%BB%20x,%20x%20+%203)%205%20=%208%20:=%20rfl%0Aexample%20:%20(%CE%BB%20x,%20f%20x)%20=%20f%20:=%20rfl%0Aexample%20(p%20:%20Prop)%20(h%E2%82%81%20h%E2%82%82%20:%20p)%20:%20h%E2%82%81%20=%20h%E2%82%82%20:=%20rfl" target="_blank">
try it!</a></div><div class="highlight-lean"><div class="highlight"><pre><span class="bp">#</span><span class="n">reduce</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">x</span> <span class="bp">+</span> <span class="mi">3</span><span class="o">)</span> <span class="mi">5</span>
<span class="bp">#</span><span class="n">eval</span>   <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">x</span> <span class="bp">+</span> <span class="mi">3</span><span class="o">)</span> <span class="mi">5</span>

<span class="bp">#</span><span class="n">reduce</span> <span class="k">let</span> <span class="n">x</span> <span class="o">:=</span> <span class="mi">5</span> <span class="k">in</span> <span class="n">x</span> <span class="bp">+</span> <span class="mi">3</span>
<span class="bp">#</span><span class="n">eval</span>   <span class="k">let</span> <span class="n">x</span> <span class="o">:=</span> <span class="mi">5</span> <span class="k">in</span> <span class="n">x</span> <span class="bp">+</span> <span class="mi">3</span>

<span class="kn">def</span> <span class="n">f</span> <span class="n">x</span> <span class="o">:=</span> <span class="n">x</span> <span class="bp">+</span> <span class="mi">3</span>

<span class="bp">#</span><span class="n">reduce</span> <span class="n">f</span> <span class="mi">5</span>
<span class="bp">#</span><span class="n">eval</span>   <span class="n">f</span> <span class="mi">5</span>

<span class="bp">#</span><span class="n">reduce</span> <span class="bp">@</span><span class="n">nat</span><span class="bp">.</span><span class="n">rec</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">n</span><span class="o">,</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="mi">0</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">n</span> <span class="n">recval</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">,</span> <span class="n">recval</span> <span class="bp">+</span> <span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="mi">5</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span>
<span class="bp">#</span><span class="n">eval</span>   <span class="bp">@</span><span class="n">nat</span><span class="bp">.</span><span class="n">rec</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">n</span><span class="o">,</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="mi">0</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">n</span> <span class="n">recval</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">,</span> <span class="n">recval</span> <span class="bp">+</span> <span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="mi">5</span> <span class="o">:</span> <span class="n">ℕ</span><span class="o">)</span>

<span class="kn">def</span> <span class="n">g</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span> <span class="n">ℕ</span>
<span class="bp">|</span> <span class="mi">0</span>     <span class="o">:=</span> <span class="mi">0</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="o">:=</span> <span class="n">g</span> <span class="n">n</span> <span class="bp">+</span> <span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span>

<span class="bp">#</span><span class="n">reduce</span> <span class="n">g</span> <span class="mi">5</span>
<span class="bp">#</span><span class="n">eval</span>   <span class="n">g</span> <span class="mi">5</span>

<span class="bp">#</span><span class="n">eval</span>   <span class="n">g</span> <span class="mi">50000</span>

<span class="kn">example</span> <span class="o">:</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">x</span> <span class="bp">+</span> <span class="mi">3</span><span class="o">)</span> <span class="mi">5</span> <span class="bp">=</span> <span class="mi">8</span> <span class="o">:=</span> <span class="n">rfl</span>
<span class="kn">example</span> <span class="o">:</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">f</span> <span class="n">x</span><span class="o">)</span> <span class="bp">=</span> <span class="n">f</span> <span class="o">:=</span> <span class="n">rfl</span>
<span class="kn">example</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">(</span><span class="n">h₁</span> <span class="n">h₂</span> <span class="o">:</span> <span class="n">p</span><span class="o">)</span> <span class="o">:</span> <span class="n">h₁</span> <span class="bp">=</span> <span class="n">h₂</span> <span class="o">:=</span> <span class="n">rfl</span>
</pre></div>
</div>
</div><p>Note: the combination of proof irrelevance and singleton <code class="docutils literal"><span class="pre">Prop</span></code> elimination in ι-reduction renders the ideal version of definitional equality, as described above, undecidable. Lean’s procedure for checking definitional equality is only an approximation to the ideal. It is not transitive, as illustrated by the example below. Once again, this does not compromise the consistency or soundness of Lean; it only means that Lean is more conservative in the terms it recognizes as well typed, and this does not cause problems in practice. Singleton elimination will be discussed in greater detail in <a class="reference internal" href="declarations.html#inductive-definitions"><span class="std std-ref">Inductive Definitions</span></a>.</p>
<p><strong>Example</strong></p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://gebner.github.io/lean-web-editor/#code=def%20R%20(x%20y%20:%20unit)%20:=%20false%0Adef%20accrec%20:=%20&#64;acc.rec%20unit%20R%20(%CE%BB_,%20unit)%20(%CE%BB%20_%20a%20ih,%20())%20()%0Aexample%20(h)%20:%20accrec%20h%20=%20accrec%20(acc.intro%20_%20(%CE%BB%20y,%20acc.inv%20h))%20:=%20rfl%0Aexample%20(h)%20:%20accrec%20(acc.intro%20_%20(%CE%BB%20y,%20acc.inv%20h))%20=%20()%20:=%20rfl%0Aexample%20(h)%20:%20accrec%20h%20=%20()%20:=%20sorry%20%20%20--%20rfl%20fails" target="_blank">
try it!</a></div><div class="highlight-lean"><div class="highlight"><pre><span class="kn">def</span> <span class="n">R</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">unit</span><span class="o">)</span> <span class="o">:=</span> <span class="n">false</span>
<span class="kn">def</span> <span class="n">accrec</span> <span class="o">:=</span> <span class="bp">@</span><span class="n">acc</span><span class="bp">.</span><span class="n">rec</span> <span class="n">unit</span> <span class="n">R</span> <span class="o">(</span><span class="bp">λ</span><span class="n">_</span><span class="o">,</span> <span class="n">unit</span><span class="o">)</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">_</span> <span class="n">a</span> <span class="n">ih</span><span class="o">,</span> <span class="o">())</span> <span class="o">()</span>
<span class="kn">example</span> <span class="o">(</span><span class="n">h</span><span class="o">)</span> <span class="o">:</span> <span class="n">accrec</span> <span class="n">h</span> <span class="bp">=</span> <span class="n">accrec</span> <span class="o">(</span><span class="n">acc</span><span class="bp">.</span><span class="n">intro</span> <span class="n">_</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">y</span><span class="o">,</span> <span class="n">acc</span><span class="bp">.</span><span class="n">inv</span> <span class="n">h</span><span class="o">))</span> <span class="o">:=</span> <span class="n">rfl</span>
<span class="kn">example</span> <span class="o">(</span><span class="n">h</span><span class="o">)</span> <span class="o">:</span> <span class="n">accrec</span> <span class="o">(</span><span class="n">acc</span><span class="bp">.</span><span class="n">intro</span> <span class="n">_</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">y</span><span class="o">,</span> <span class="n">acc</span><span class="bp">.</span><span class="n">inv</span> <span class="n">h</span><span class="o">))</span> <span class="bp">=</span> <span class="o">()</span> <span class="o">:=</span> <span class="n">rfl</span>
<span class="kn">example</span> <span class="o">(</span><span class="n">h</span><span class="o">)</span> <span class="o">:</span> <span class="n">accrec</span> <span class="n">h</span> <span class="bp">=</span> <span class="o">()</span> <span class="o">:=</span> <span class="n">sorry</span>   <span class="c1">-- rfl fails</span>
</pre></div>
</div>
</div></div>
<div class="section" id="axioms">
<h2>Axioms<a class="headerlink" href="#axioms" title="Permalink to this headline">¶</a></h2>
<p>Lean’s foundational framework consists of:</p>
<ul class="simple">
<li>the core elements of the calculus of constructions, with type universes and dependent function types, as described above</li>
<li>inductive types, as described in <a class="reference internal" href="declarations.html"><span class="doc">Declarations</span></a>.</li>
</ul>
<p>In addition, the core library defines (and trusts) the following axiomatic extensions:</p>
<ul class="simple">
<li>propositional extensionality: …</li>
<li>quotients: …</li>
<li>choice: …</li>
</ul>
<p>The last principle, in conjunction with the others, makes the axiomatic foundation classical. Functions that make use of <code class="docutils literal"><span class="pre">choice</span></code> to produce data are incompatible with a computational interpretation, and do not produce bytecode. They have to be declared <code class="docutils literal"><span class="pre">noncomputable</span></code>.</p>
<p>For metaprogramming purposes, Lean also allows the definition of objects which stand outside the object language. These are denoted with the <code class="docutils literal"><span class="pre">meta</span></code> keyword, as described in <a class="reference internal" href="programming.html"><span class="doc">Programming</span></a>.</p>
</div>
</div>


           </div>
           <div class="articleComments">
            
           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="declarations.html" class="btn btn-neutral float-right" title="Declarations" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="lexical_structure.html" class="btn btn-neutral" title="Lexical Structure" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2017, Jeremy Avigad.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'./',
            VERSION:'master',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="_static/jquery.js"></script>
      <script type="text/javascript" src="_static/underscore.js"></script>
      <script type="text/javascript" src="_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>